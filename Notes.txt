Flags contain 1 bit each, aka boolean
They are *likely?* used to determine some other calls
CF = Carry
PF = Parity
ZF = Zero
SF = Sign
OF = Overflow
AF = Adjust
IF = Interupt Enabled

Pointers, I know this from C:
rip, eip, ip = index pointers
rsp, esp, sp = stack pointers
rbp, ebp, bp = stack base pointers
... much more

Control Flow is the direction of the program flow,
the index pointer (rip) determines which line is next to execute

Control Flow calls:
jmp, changing rip
cmp, used for setting a flag
  a==b sets ZF = 1
  a!=b sets ZF = 0
  SF will be the most significant bit of a-b
Conditional Jumps:
  Pretty much same as bash, equal, not equal, less than...
  and it does depend on flags

'''asm
  cmp rax, 23
  je _doThis
''' 
Moves to the label if rax is equal to 23.

Also
'''asm
  mov rax, rbx ; same as int a = b in C
  mov rax, [rbx]; would do int a = *b in C
''' 
[rbx] is the address, however you can only do this
with 64bit registers, since thats the size of pointers


Calls are pretty much jumps to specific functions,
you need a defined block with a ret at the end.

The stack works with 64 bit values, so when you are 
pushing a value from memory into the stack, you need
to convert it to a qword (quad word is 64 bits).

The stack at the beginning stores in this sequence:
-argc
-path
-argv[1]...

Writing to files also depends on the linux permissions,
it the same octal values you learn when you start getting
into file management, so I won't go over this.
SYS_OPEN returns you a file descriptor into the rax register.

db == define bytes
dw == define word, 16 bits/2 bytes 
dd == define double word, 32 bits/4 bytes
dq == define quadruple word, 64 bits/8 bytes
This is pretty elementary but I guess important so I'll leave it here.

sys_nanosleep takes a struct of timespec.
the two arguments are both pointers, so you need in
defined in the main memory.


Including C functions need to be linked with the C standard
This is achieved by assembling a .asm file with nasm, and:
> gcc -no-pie {}.o -o {} -lc
and it would successfully link if you follow the C asm format.

This includes having a defined main label.
And a prologue:
'''asm
  push rbp
  mov rbp, rsp
''' 

And an epilogue:
'''asm
  leave
  ; which is actually just
  ; mov rsp, rbp
  ; pop rbp
''' 

And a ret at the end so to not cause a seg fault and exit propertly.

Also important to mention that the heap and the stack are both
found in the RAM, the program's stack is mostly static, while
the heap is dynamic and done at runtime with syscalls. 
(which is very slow)
The heap is also worse for cache locality but we can get virtually
unlimited space, which is not the case for the stack.

The heap also consists of a fragmentator, I won't go into this
since fragmentation is pretty trivial.
The main point is that the stack never needs to use a fragmentator.

This is also an insanely good case for how slow linked lists are
compared to arrays and even vectors (ArrayLists). 
And it can be also used for the support of linear allocators or arenas. 

If all of the above is done correctly, the heap can be about just as
fast as the stack, when it comes to memory accessing, altho it's
allocation is awfully slow.

BUT, its actually possible to resize variables on the stack, altho it would
require a new allocated memory space to keep the current heap, popping until we reach
the variable, resizing the variables needed, and the pushing back.
(This is also really slow, but I suppose its possible)

16-bit 8086:
ax, ah/al, general purpose
bx, bh/bl, general purpose (used in the c++ compiler by microsoft)
cx, ch/cl, general purpose (often as the counter and for loops)
dx, dh/dl, general purpose
si, source index
di, destination index
cs, segment
ds, segment
es, segment
ss, segment
flags (comparasings and branching things alike, at the top of the txt file)

Segments were used for segmented memory, but now we have flat memory.

32-bit 80386:
eax, ax, ah/al, general purpose
ebx, bx, bh/bl, general purpose
ecx, cx, ch/cl, general purpose
edx, dx, dh/dl, general purpose
esi, si, source index
edi, di, destination index
ebp, bp, base pointer
esp, sp, stack pointer 
eip, ip, instruction pointer
eFlags, Flags, just the basic flags

And also the deprecated segment registers:
cs, ds, es, ss, fs, gs 
fs and gs were additions the segment registers
instead of the increase in size of the existing ones.

Pentium IV, first x64:
rax, eax, ax, ah/al, general purpose
rbx, ebx, bx, bh/bl, general purpose
rcx, ecx, cx, ch/cl, general purpose
rdx, edx, dx, dh/dl, general purpose
rsi, esi, si, sil, source index (xil variant to get to the lowest)
rdi, edi, di, dil, destination index
rbp, ebp, bp, spl, base pointer (also the xpl)
rsp, esp, sp, bpl, stack pointer 
rip, eip, instruction pointer (loss of ip)
r8, r8d, r8w, r8b, general purpose
r9, r9d, r9w, r9b, general purpose
r10, r10d, r10w, r10b, general purpose //new registers, D for double
r11, r11d, r11w, r11b, general purpose //word, so 32 bytes
r12, r12d, r12w, r12b, general purpose //W for word or 16 bits
r13, r13d, r13w, r13b, general purpose //B for byte or 8 bits
r14, r14d, r14w, r14b, general purpose //so total 17 registers in total
r15, r15d, r15w, r15b, general purpose //ax-ip regs didn't change for compat
RFlags, EFlags, Flags, just the basic flags

Using instructions with 32 bit registers will zero the top of 64 bit ones
however 8 bit and 16 bit dont, however you can still write x64 as x86
and that is why there is program compatability.

Using original registers generates more efficient machine code
since the newer x64 registers and instructions add a REX prefix
in the machine code translation.

Datatypes in x64:
Integers consist of byte, word, dword and qword
Ints can also be signed of unsigned, but you keep track of that
Floating points are real4, real8, real10
and the SIMD pointers are xmmword, ymmword, zmmword

all real types are IEEE754
real4 is single precision float:
1 bit sign
8 bit exponent
23 bit mantissa

real8 is double precision:
1 bit sign
11 bit exponent
52 bit mantissa

real10 which is not available in all compilers
and is only used in X87 FPU, amazing precision
is extended precision float:
1 bit sign
15 bit exponent
64 bit mantissa

SIMD packed data:
xmmword: 128 bits (SSE packed)
ymmword: 256 bits (AVX)
zmmword: 512 bits (AVX512, not in all cpus)


Instructions:
mov, only loads value
mov ax, [RBP+RSI+5] ; gets the value at that address
mov is also the only instruction that allows for immediate
64 bit operands, others will cause sign extension.

sign extension means that if the 31th bit is a 1, all the rest 
would become 1s as well so 0xfffff...

movzx, is the same as mov except it zero extends the smaller source operand


lea, loads/calculates effective address
lea ax, [RBP+RSI+5] ; gets the adress 


Arithmetic:

Add only adds, obviously
however you can use
add REG, 0
to update the flags according to the reg

you can also do 
add REG, 1
to increment but also update the carry flag

and since add is faster than mul
doing 
mov rax, 2
mul rbx
mov rbx, rax

is slower than

add rbx, rbx


Sub, only subtracts, obviously
overflow means a signed borrow
carry means unsigned borrow
a quick way to zero is sub reg, reg
however
xor reg, reg ; is faster
sub reg, 1 is the same a dec reg, except it affects the carry flag

Mul, multiplication
Imul, unsigned multiplication
Div, division, if rdx is not zero it concats with rax to a 128 bit register
Idiv, same as above, and if the rdx is empty then the remainder is stored there

Boolean algebra:
xor
or
and
not
Pretty simple, and I dealt with this a bunch so I won't go into it
and it's pretty much an entire seperate field.
obviously out of this you can make more complex gates.

Bit manipulations:

shifts:
shl
shr

if the final bit shifts out, it will set the carry flag as one.
With a positive signed number, its faster to shr than div 2. 
(Unless you shift into the sign bit)
Also with unsigned numbers, it has no downsides.

arithmetic shifts:
sal
sar

Fix all of the problems with regular shifts, but at a cost of
performance.

rotate:
rol
ror

This for whatever reason does not exist in the C standard.
Altho compilers may recognize similar functions.
Its shifting to one side except it's like a looped list.

rotate through the carry flag:
rcl
rcr

Sets the carry flag as an extra bit, so registers would act 
as if they were 65 bit, pretty much just concats and then shifts.
Hard to implement in many languages.

double precision shifts:
rold
rord

Concats two registers so we get 128 bits, and then shifts them.

Basic Flags:
0 - CF, carry, an unsigned overflow
2 - PF, parity, old, backwards compat for data transmission
4 - AF, auxiliary, not applicable in x64, overflow or carry of lowest 4 bits (nibble)
6 - ZF, zero, if result is zero then set to 1
7 - SF, sign, 1 for negative, 0 for positive
8 - TF, trap, allows for debuggers to step through the code
9 - IF, interrupt, allows interrupts to be called
10 - DF, direction, 0 reading string forwards, 1 for backwards
11 - OF, overflow, a signed overflow
12,13 - IOPL, shows IO port privilege level
14 - NT, shows if this task is nested
Some flags are general purpose but most are not in use.

pushfq would push the entire flag register to the stack,
popfq would get the top of the stack into the flag register.

Other flags:
15 - MD, mode flag NEC V-series only
16 - RF, resume flag, used to manage floating point exceptions in the FPU
17 - VM, virtual mode, a hardware virtualization technique
18 - AC, alignment check, if 0 the processor does not generated expections for misaligned memory
19 - VIF, virtual interrupt, Pentium+
20 - VIP, virtual interrupt pending, Pentium+
21 - ID, able to use the CPUID instruction on Pentium+
30 - (none), AES key schedule loaded flag (VIA PadLock only)
31 - AI, Alternate Instruction Set, enabled VIA C5XL processors only

Rflags are reserved.

Without the capability to do things conditionaly, computers would be
severly underpowered because they could only execute simple programs.
Conditions operate by checking flags and branching accordingly.

Conditionals:
Jumps/jcc, if the condition cc is true, the processor would only change
the instruction pointer by a relative offset, which in return will change
the next line of instructions.

Moves/cmovcc, if cc then it moves, it also doesn't support immediate 
values, nor 8 bit version.

Set Byte/setcc, if true, then it sets the byte to 00000001, else 0

CC:
JE/JZ: Zero
JNE/JNZ: Not Zero
JO: Overflow
JNO: Not Overflow
JB/JC/JNAE: Carry Unsigned
JNB/JNC/JAE: Not Carry Unsigned
JBE/JNA: Below or Equal Unsigned
JNBE: Above Unsigned
JS: Sign
JNS: Not Sign
JP/JPE: Parity Even
JNP/JPO: Parity Odd
JL/JNGE: Less Signed
JNL/JGE: Not Less Signed
JLE/JNG: Not Greater Signed
JNLE/JG: Greater Signed



