Credits to:

1. Creel on youtube for his material, 
mainly focusing on the hardware specifics
https://www.youtube.com/@WhatsACreel

2. kupala on youtube for his material,
mainly focusing on the linux interactions with asm
https://www.youtube.com/@khoraski


Flags contain 1 bit each, aka boolean
They are *likely?* used to determine some other calls
CF = Carry
PF = Parity
ZF = Zero
SF = Sign
OF = Overflow
AF = Adjust
IF = Interupt Enabled

Pointers, I know this from C:
rip, eip, ip = index pointers
rsp, esp, sp = stack pointers
rbp, ebp, bp = stack base pointers
... much more

Control Flow is the direction of the program flow,
the index pointer (rip) determines which line is next to execute

Control Flow calls:
jmp, changing rip
cmp, used for setting a flag
  a==b sets ZF = 1
  a!=b sets ZF = 0
  SF will be the most significant bit of a-b
Conditional Jumps:
  Pretty much same as bash, equal, not equal, less than...
  and it does depend on flags

'''asm
  cmp rax, 23
  je _doThis
''' 
Moves to the label if rax is equal to 23.

Also
'''asm
  mov rax, rbx ; same as int a = b in C
  mov rax, [rbx]; would do int a = *b in C
''' 
[rbx] is the address, however you can only do this
with 64bit registers, since thats the size of pointers


Calls are pretty much jumps to specific functions,
you need a defined block with a ret at the end, and they 
work by changing rip and then changing it back with ret.

The stack works with 64 bit values, so when you are 
pushing a value from memory into the stack, you need
to convert it to a qword (quad word is 64 bits).

The stack at the beginning stores in this sequence:
-argc
-path
-argv[1]...

Writing to files also depends on the linux permissions,
it the same octal values you learn when you start getting
into file management, so I won't go over this.
SYS_OPEN returns you a file descriptor into the rax register.

db == define bytes
dw == define word, 16 bits/2 bytes 
dd == define double word, 32 bits/4 bytes
dq == define quadruple word, 64 bits/8 bytes
This is pretty elementary but I guess important so I'll leave it here.

sys_nanosleep takes a struct of timespec.
the two arguments are both pointers, so you need in
defined in the main memory.


Including C functions need to be linked with the C standard
This is achieved by assembling a .asm file with nasm, and:
> gcc -no-pie {}.o -o {} -lc
and it would successfully link if you follow the C asm format.

This includes having a defined main label.
And a prologue:
'''asm
  push rbp
  mov rbp, rsp
''' 

And an epilogue:
'''asm
  leave
  ; which is actually just
  ; mov rsp, rbp
  ; pop rbp
''' 

And a ret at the end so to not cause a seg fault and exit propertly.

Also important to mention that the heap and the stack are both
found in the RAM, the program's stack is mostly static, while
the heap is dynamic and done at runtime with syscalls. 
(which is very slow)
The heap is also worse for cache locality but we can get virtually
unlimited space, which is not the case for the stack.

The heap also consists of a fragmentator, I won't go into this
since fragmentation is pretty trivial.
The main point is that the stack never needs to use a fragmentator.

This is also an insanely good case for how slow linked lists are
compared to arrays and even vectors (ArrayLists). 
And it can be also used for the support of linear allocators or arenas. 

If all of the above is done correctly, the heap can be about just as
fast as the stack, when it comes to memory accessing, altho it's
allocation is awfully slow.

BUT, its actually possible to resize variables on the stack, altho it would
require a new allocated memory space to keep the current heap, popping until we reach
the variable, resizing the variables needed, and the pushing back.
(This is also really slow, but I suppose its possible)

16-bit 8086:
ax, ah/al, general purpose
bx, bh/bl, general purpose (used in the c++ compiler by microsoft)
cx, ch/cl, general purpose (often as the counter and for loops)
dx, dh/dl, general purpose
si, source index
di, destination index
cs, segment
ds, segment
es, segment
ss, segment
flags (comparasings and branching things alike, at the top of the txt file)

Segments were used for segmented memory, but now we have flat memory.

32-bit 80386:
eax, ax, ah/al, general purpose
ebx, bx, bh/bl, general purpose
ecx, cx, ch/cl, general purpose
edx, dx, dh/dl, general purpose
esi, si, source index
edi, di, destination index
ebp, bp, base pointer
esp, sp, stack pointer 
eip, ip, instruction pointer
eFlags, Flags, just the basic flags

And also the deprecated segment registers:
cs, ds, es, ss, fs, gs 
fs and gs were additions the segment registers
instead of the increase in size of the existing ones.

Pentium IV, first x64:
rax, eax, ax, ah/al, general purpose
rbx, ebx, bx, bh/bl, general purpose
rcx, ecx, cx, ch/cl, general purpose
rdx, edx, dx, dh/dl, general purpose
rsi, esi, si, sil, source index (xil variant to get to the lowest)
rdi, edi, di, dil, destination index
rbp, ebp, bp, spl, base pointer (also the xpl)
rsp, esp, sp, bpl, stack pointer 
rip, eip, instruction pointer (loss of ip)
r8, r8d, r8w, r8b, general purpose
r9, r9d, r9w, r9b, general purpose
r10, r10d, r10w, r10b, general purpose //new registers, D for double
r11, r11d, r11w, r11b, general purpose //word, so 32 bytes
r12, r12d, r12w, r12b, general purpose //W for word or 16 bits
r13, r13d, r13w, r13b, general purpose //B for byte or 8 bits
r14, r14d, r14w, r14b, general purpose //so total 17 registers in total
r15, r15d, r15w, r15b, general purpose //ax-ip regs didn't change for compat
RFlags, EFlags, Flags, just the basic flags

Using instructions with 32 bit registers will zero the top of 64 bit ones
however 8 bit and 16 bit dont, however you can still write x64 as x86
and that is why there is program compatability.

Using original registers generates more efficient machine code
since the newer x64 registers and instructions add a REX prefix
in the machine code translation.

Datatypes in x64:
Integers consist of byte, word, dword and qword
Ints can also be signed or unsigned, but you keep track of that
Floating points are real4, real8, real10
and the SIMD pointers are xmmword, ymmword, zmmword

all real types are IEEE754
real4 is single precision float:
1 bit sign
8 bit exponent
23 bit mantissa

real8 is double precision:
1 bit sign
11 bit exponent
52 bit mantissa

real10 which is not available in all compilers
and is only used in X87 FPU, amazing precision
is extended precision float:
1 bit sign
15 bit exponent
64 bit mantissa

SIMD packed data:
xmmword: 128 bits (SSE packed)
ymmword: 256 bits (AVX)
zmmword: 512 bits (AVX512, not in all cpus)

To achieve signed integers you must use I's complement or II's complement
and they are pretty similar

I's complement:
-Positive numbers remain unchanged
-Negative numbers will get all the bits flipped
-The left most bit is the sign bit, if its 0 a number is positive
So +5 = 0101b but -5 = 1010
This leads to there being 2 representations of zero
aka 00000000 and 11111111, for positive and negative zero

When adding numbers in I's complement, if there is a carry
from the most significant bit, it will be added to the least significant bit
this process is called the end-around carry

II's complement:
-Positive numbers remain unchanged
-The left most bit is the sign bit, if its 0 a number is positive
for negative numbers, just flip all bits and then add 1

This gives you only a value for zero
and also simplified arithmetic since there is not special rules


Instructions:
mov, only loads value
mov ax, [RBP+RSI+5] ; gets the value at that address
mov is also the only instruction that allows for immediate
64 bit operands, others will cause sign extension.

sign extension means that if the 31th bit is a 1, all the rest 
would become 1s as well so 0xfffff...

movzx, is the same as mov except it zero extends the smaller source operand


lea, loads/calculates effective address
lea ax, [RBP+RSI+5] ; gets the adress 


Arithmetic:

Add only adds, obviously
however you can use
add REG, 0
to update the flags according to the reg

you can also do 
add REG, 1
to increment but also update the carry flag

and since add is faster than mul
doing 
mov rax, 2
mul rbx
mov rbx, rax

is slower than

add rbx, rbx


Sub, only subtracts, obviously
overflow means a signed borrow
carry means unsigned borrow
a quick way to zero is sub reg, reg
however
xor reg, reg ; is faster
sub reg, 1 is the same a dec reg, except it affects the carry flag

Mul, multiplication
Imul, unsigned multiplication
Div, division, if rdx is not zero it concats with rax to a 128 bit register
Idiv, same as above, and if the rdx is empty then the remainder is stored there

Boolean algebra:
xor
or
and
not
Pretty simple, and I dealt with this a bunch so I won't go into it
and it's pretty much an entire seperate field.
obviously out of this you can make more complex gates.

Bit manipulations:

shifts:
shl
shr

if the final bit shifts out, it will set the carry flag as one.
With a positive signed number, its faster to shr than div 2. 
(Unless you shift into the sign bit)
Also with unsigned numbers, it has no downsides.

arithmetic shifts:
sal
sar

Fix all of the problems with regular shifts, but at a cost of
performance.

rotate:
rol
ror

This for whatever reason does not exist in the C standard.
Altho compilers may recognize similar functions.
Its shifting to one side except it's like a looped list.

rotate through the carry flag:
rcl
rcr

Sets the carry flag as an extra bit, so registers would act 
as if they were 65 bit, pretty much just concats and then shifts.
Hard to implement in many languages.

double precision shifts:
rold
rord

Concats two registers so we get 128 bits, and then shifts them.

Basic Flags:
0 - CF, carry, an unsigned overflow
2 - PF, parity, old, backwards compat for data transmission
4 - AF, auxiliary, not applicable in x64, overflow or carry of lowest 4 bits (nibble)
6 - ZF, zero, if result is zero then set to 1
7 - SF, sign, 1 for negative, 0 for positive
8 - TF, trap, allows for debuggers to step through the code
9 - IF, interrupt, allows interrupts to be called
10 - DF, direction, 0 reading string forwards, 1 for backwards
11 - OF, overflow, a signed overflow
12,13 - IOPL, shows IO port privilege level
14 - NT, shows if this task is nested
Some flags are general purpose but most are not in use.

pushfq would push the entire flag register to the stack,
popfq would get the top of the stack into the flag register.

Other flags:
15 - MD, mode flag NEC V-series only
16 - RF, resume flag, used to manage floating point exceptions in the FPU
17 - VM, virtual mode, a hardware virtualization technique
18 - AC, alignment check, if 0 the processor does not generated expections for misaligned memory
19 - VIF, virtual interrupt, Pentium+
20 - VIP, virtual interrupt pending, Pentium+
21 - ID, able to use the CPUID instruction on Pentium+
30 - (none), AES key schedule loaded flag (VIA PadLock only)
31 - AI, Alternate Instruction Set, enabled VIA C5XL processors only

Rflags are reserved.

Without the capability to do things conditionaly, computers would be
severly underpowered because they could only execute simple programs.
Conditions operate by checking flags and branching accordingly.

Conditionals:
Jumps/jcc, if the condition cc is true, the processor would only change
the instruction pointer by a relative offset, which in return will change
the next line of instructions.

Moves/cmovcc, if cc then it moves, it also doesn't support immediate 
values, nor 8 bit version.

Set Byte/setcc, if true, then it sets the byte to 00000001, else 0

CC:
JE/JZ: Zero
JNE/JNZ: Not Zero
JO: Overflow
JNO: Not Overflow
JB/JC/JNAE: Carry Unsigned
JNB/JNC/JAE: Not Carry Unsigned
JBE/JNA: Below or Equal Unsigned
JNBE: Above Unsigned
JS: Sign
JNS: Not Sign
JP/JPE: Parity Even
JNP/JPO: Parity Odd
JL/JNGE: Less Signed
JNL/JGE: Not Less Signed
JLE/JNG: Not Greater Signed
JNLE/JG: Greater Signed

Calling convention:

Windows "C" Calling Convention 
The first 4 args are stored in the registers
xmm0 are used for floating points, while regular regs
are for ints, pointers, arrays, objs
1st: rcx/xmm0
2nd: rdx/xmm1
3rd: r8/xmm2
4th: r9/xmm3
The rest get pushed to the stack.

The return value can be found in the rax register.

Linux Calling Convention
When calling from the commandline, the arguments are
stored like this.
The stack at the beginning stores in this sequence:
-argc
-path
-argv[1]...
Within functions, the first 6 args are
rdi, rsi, rdx, rcx, r8, r9
and the rest are pushed onto the stack
rax is the return value
rdx is optionally the 2nd return value
rbx is optionally used as a base pointer

Structures in Assembly:
In nasm, you start a struct by doing
struc *name*
  *var1*: resd/resw/resb...
  *var2*...
  ...
endstruc

The correct way of accessing structs is doing
mov ax, [*name_struct*+*varx*]

to have multipul structures with the same members
you should prepend the variable with a dot
in that case you would do 
mov ax, [*name_struct*+*name.var*]

to make an instance of a struct in your data segment
you do something like this

*name_struct*:
  istruc *name*
    at *var1*, dd 12321
    at *str1*, db "hello world"
  iend

puting *at* before var names will force them to be
defined in the same order as written

to create an uninitalized instance you just put the
"?" inside the dd/db/... field

also the dup keyword duplicates so
3 dup(0), would duplicate 3 zeroes

assembler doesn't know about classes and it does
not care about private nor public, methods don't
get defined, so its the same as structs

for a union, you would just say one symbol is 
the same as another, so just use
  var1 resd 1
  var2 equ var1

if you want the full capabilities of unions
you need to implement unions yourself
since there is no native union support

nested structures are quite simple
in the struc declaration you would want to 
reserve bytes for the struct

struc inner_struct
  var1: resw1
  var2: resb 30
endstruc

struc outer_struct
  var1: inner_struct
  var2: resw 1
endstruc

and for nested structs we actually need to 
use the dot operator
  mov ax, [outer_struct_instance.var1.var2]
this would lead to the resb 30


SIMD:
Single Instruction Multipul Data (MIMD AND MISD also exist)
To achieve higher performance, architects started creating 
processors with higher clock speeds, but that leads to more
power drawing, as a solution they started making processors
with multipul cores and achieveing paralelism
... and at last SIMD and vectorized instrucitons

The instruction sets are:
-x64: SSE, AVX, AVX512, MMX, BMI, (TBM, XOP in amd) (FMA in addition)
-arm: neon, sve...
-risc-v...

MMX (1997): MM0-MM7
SSE (1999): XMM0-XMM15
AVX (2011): YMM0-YMM15
AVX512 (2016): ZMM0-ZMM15
512/256/128/64

SSE can do operations on as much variables you can
fit within a single 128 bit space, so for example 
it can do operations on 2 quad words at the same time.

Same aplies to AVX and AVX512.

Data needs to be aligned aka evenly divisible by 
some number the instruction and data decide.

SSE instructions:
for packed data aka simd you just add *ps at the end
of an instruction, if you for some reason want to do 
it with a scalar, you'd do *ss, pretty simple
the s at the end stand for single precision tho 
you can change it for a d for double precision
if its unaligned you add *u* before the sufix

AVX instructions:
same as SSE except you put a prefix of v* before
the instruction.
Also it supports 3 register instruction so you 
dont need to align the store address
dont need to be destructive with the inputs
unlike SSE.  
It has upgraded sse by allowing it to be 
non distructive with the 128 bit registers.
You can also add a prefix a* before the sufix
if you know that your data is aligned.

CPUID is used to check if the hardware is capable of
performing some of these advanced instructions.
If you run newer instructions on older hardware 
you will crash with an illegal instruction error.
AVX512 is not supported by my cpu, checked by CPUID.

AVX512 info:
Introduces a new kind of registers, that are really useful
for branchless programming, the K masks.
K0-K7, altho K0 is not to be used, and they are 64 bits.
kmov*, kadd*, kand*, knot*, kor*, kortest*, kshiftl*, ktest*
kunpck[bw/wd/dq], kx[nor/or]*...
*=[b/w/d/q]
[b/w/d/q]
It had also introduced casting floats to integers, or rounding.
And compressed displacement, which is quite convinient.


arithmetic:
{V}[add/sub/mul/div][u/a/ ][s/p][s/d]



