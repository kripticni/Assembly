Flags contain 1 bit each, aka boolean
They are *likely?* used to determine some other calls
CF = Carry
PF = Parity
ZF = Zero
SF = Sign
OF = Overflow
AF = Adjust
IF = Interupt Enabled

Pointers, I know this from C:
rip, eip, ip = index pointers
rsp, esp, sp = stack pointers
rbp, ebp, bp = stack base pointers
... much more

Control Flow is the direction of the program flow,
the index pointer (rip) determines which line is next to execute

Control Flow calls:
jmp, changing rip
cmp, used for setting a flag
  a==b sets ZF = 1
  a!=b sets ZF = 0
  SF will be the most significant bit of a-b
Conditional Jumps:
  Pretty much same as bash, equal, not equal, less than...
  and it does depend on flags

'''asm
  cmp rax, 23
  je _doThis
''' 
Moves to the label if rax is equal to 23.

Also
'''asm
  mov rax, rbx ; same as int a = b in C
  mov rax, [rbx]; would do int a = *b in C
''' 
[rbx] is the address, however you can only do this
with 64bit registers, since thats the size of pointers


Calls are pretty much jumps to specific functions,
you need a defined block with a ret at the end.

The stack works with 64 bit values, so when you are 
pushing a value from memory into the stack, you need
to convert it to a qword (quad word is 64 bits).

The stack at the beginning stores in this sequence:
-argc
-path
-argv[1]...

Writing to files also depends on the linux permissions,
it the same octal values you learn when you start getting
into file management, so I won't go over this.
SYS_OPEN returns you a file descriptor into the rax register.

db == define bytes
dw == define word, 16 bits/2 bytes 
dd == define double word, 32 bits/4 bytes
dq == define quadruple word, 64 bits/8 bytes
This is pretty elementary but I guess important so I'll leave it here.

sys_nanosleep takes a struct of timespec.
the two arguments are both pointers, so you need in
defined in the main memory.


Including C functions need to be linked with the C standard
This is achieved by assembling a .asm file with nasm, and:
> gcc -no-pie {}.o -o {} -lc
and it would successfully link if you follow the C asm format.

This includes having a defined main label.
And a prologue:
'''asm
  push rbp
  mov rbp, rsp
''' 

And an epilogue:
'''asm
  leave
  ; which is actually just
  ; mov rsp, rbp
  ; pop rbp
''' 

And a ret at the end so to not cause a seg fault and exit propertly.

Also important to mention that the heap and the stack are both
found in the RAM, the program's stack is mostly static, while
the heap is dynamic and done at runtime with syscalls. 
(which is very slow)
The heap is also worse for cache locality but we can get virtually
unlimited space, which is not the case for the stack.

The heap also consists of a fragmentator, I won't go into this
since fragmentation is pretty trivial.
The main point is that the stack never needs to use a fragmentator.

This is also an insanely good case for how slow linked lists are
compared to arrays and even vectors (ArrayLists). 
And it can be also used for the support of linear allocators or arenas. 

If all of the above is done correctly, the heap can be about just as
fast as the stack, when it comes to memory accessing, altho it's
allocation is awfully slow.

BUT, its actually possible to resize variables on the stack, altho it would
require a new allocated memory space to keep the current heap, popping until we reach
the variable, resizing the variables needed, and the pushing back.
(This is also really slow, but I suppose its possible)
